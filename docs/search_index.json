[["index.html", "Graph Algorithms 1 Data Structures in C++", " Graph Algorithms CS 225 Course Staff 2022-10-26 1 Data Structures in C++ hugs Welcome to the Course Staff produced coursebook to pair with CS 225! We hope this really helps you learn more and improves your code. Report any issues at our Github repo and we’ll be sure to credit you as well :) "],["c-introduction.html", "2 C++ Introduction", " 2 C++ Introduction "],["arrays-and-lists.html", "3 Arrays and Lists", " 3 Arrays and Lists "],["trees.html", "4 Trees 4.1 Basic tree terminology 4.2 Tree Property: Height 4.3 Tree Property: Binary 4.4 Tree Property: Full 4.5 Tree Property: Perfect 4.6 Tree Property: Complete 4.7 Tree Traversals 4.8 Searching Trees 4.9 Delete and Insert", " 4 Trees Trees are a hierarchical data structure with a certain set of properties that distinguish it from graphs. Trees are rooted, which means that there is a pointer to the root node and each child node can be reached via the root. 4.1 Basic tree terminology (adapted from CS 173) * Vertex: “nodes” Path: sequence of edges Parents: Node b, d, x have Node a as their parent Children: b, d, x, are the children of a Siblings: b, d, x, are siblings of each other Ancestors: u has ancestors l, d, a Descendants: x has s, m as its descendants Leaves: Vertices with no children 4.2 Tree Property: Height Computation of the tree height The length of the longest path from the root to the leaf (count edges). If we want to compute recursively: height(T) = 1 + max(height(TL), height(TR)), where if height(null) = -1, which might be counter-intuitive but it follows the mathematical definition of tree height 4.3 Tree Property: Binary A binary tree is either T = {TL, TR, r}, where TL, TR are binary trees T = {} =  \\(\\emptyset\\) 4.4 Tree Property: Full A binary tree is full if and only if Either: F = {} Or: F = {TL, TR, r} where TL, TR both have either 0 or 2 children Theorem: A binary tree with n data items has n+1 null pointers. 4.5 Tree Property: Perfect A perfect tree Ph is defined by its height Ph is a tree of height h, with P-1 = {} Ph = {r, Ph-1, Ph-1} when h&gt;=0 4.6 Tree Property: Complete (as defined in data structures) * A complete tree is * A perfect tree except for the last level All leaves must be pushed to the left Or, recursively, a complete tree Ch of height h is C-1 = {} Ch = {r, TL, TR} where Either: TL = Ch-1 and TR = Ph-2 Or:TL = Ph-1 and TR = Ch-1 Full does not imply perfect, so as complete does not imply perfect Not full implies not perfect, thus perfect implies full; perfect also implies complete too. 4.7 Tree Traversals (practice them here: https://yongdanielliang.github.io/animation/web/BST.html) * Pre-Order: process the data first, then left child, then the right child * In-Order: left child, process the data, right child * Post-Order: left child, right child, process the data last void BinaryTree&lt;T&gt;::preOrder(TreeNode * cur) { if (cur != NULL) { func(curr-&gt;data); preOrder(curr-&gt;left); preOrder(curr-&gt;right); } } void BinaryTree&lt;T&gt;::inOrder(TreeNode * cur) { if (cur != NULL) { preOrder(curr-&gt;left); func(curr-&gt;data); preOrder(curr-&gt;right); } } void BinaryTree&lt;T&gt;::inOrder(TreeNode * cur) { if (cur != NULL) { preOrder(curr-&gt;left); preOrder(curr-&gt;right); func(curr-&gt;data); } } 4.8 Searching Trees BFS: breadth first search: visits nodes at each level (level-order traversal): use a queue DFS: depth first search: find the endpoint of the path quickly (in order, pre order or post order): use a stack Traversal vs Search: traverse visits every node vs search visits nodes until you find what you want 4.9 Delete and Insert "],["binary-search-trees.html", "5 Binary Search Trees", " 5 Binary Search Trees "],["avl-trees.html", "6 AVL Trees", " 6 AVL Trees "],["heaps.html", "7 Heaps 7.1 Uses 7.2 min heap vs max heap 7.3 Array based implementation 7.4 insert() - Heapify up 7.5 Heapify down 7.6 Build heap 7.7 Heap Sort 7.8 Priority Queue 7.9 See also:", " 7 Heaps Heaps - Add elements quickly and query/remove the most important element quickly 7.1 Uses getting the smallest/largest item each time in succession maintaining top or bottom k elements, getting the median of large datasets sorting data via heap sort 7.1.1 Pre reqs of the data Has to be orderable Has to have &gt; implemented 7.1.2 ADT implementation functions insert remove isEmpty 7.2 min heap vs max heap min heap is smallest at top and higher at the bottom max heap is the largest at top and goes smaller at the bottom the logic is basically the same in either case, just inverted - we’ll do min heap here but the similar prinicples apply to max heap quite easily 7.3 Array based implementation the simplest way to do it is with arrays that has each level contiguous it makes swaps and indexing easy not having to deal with pointers as much - we’re used to arrays 7.3.1 Compare to other implementations unsorted 7.4 insert() - Heapify up Add a bottom 7.5 Heapify down 7.6 Build heap To build a Heap in linear time we heapify down from the bottom to the top 7.6.1 Recursive proof 7.7 Heap Sort 7.8 Priority Queue 7.9 See also: Learning to Love Heaps Long Medium Post by Vaidehi Joshi Introduction to a Heap Video Series by Paul Programming Old CS 225 resources page by Eddie Huang "],["disjoint-sets.html", "8 Disjoint Sets", " 8 Disjoint Sets "],["b-trees.html", "9 B Trees", " 9 B Trees "],["hashing.html", "10 Hashing", " 10 Hashing "],["graphs.html", "11 Graphs", " 11 Graphs "],["graph-algorithms.html", "12 Graph Algorithms", " 12 Graph Algorithms "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
